<hr><li id="c39"><a href="#c0"><terminal>override</terminal> class methods and properties</a></li>
Statements:
<bin>1</bin>-all methods and properties default <terminal>final</terminal>
<bin>1</bin>-super(Base) class must be declared uses <terminal>open</terminal>
<bin>1</bin>-super(Base) class members(methods and properties) must be declared uses <terminal>open</terminal> , or will be impossible to <terminal>override</terminal>
<bin>1</bin>- <terminal>override</terminal>n member is itself <terminal>open</terminal>
<bin>1</bin>- <terminal>final override</terminal> make member <marker>impossible to be re-overriden</marker> later
<bin>1</bin>-properties can be <terminal>override</terminal>n inside <terminal>primary constructor</terminal>
<bin>1</bin>- <terminal>val</terminal> can be <terminal>override</terminal>n uses <terminal>var</terminal> , but not vice versa
<codebox>
<terminal>open</terminal> class Base{
    <bin>1</bin>    var testProperty:Int = 8 //final default
    <bin>1</bin>    <terminal>open</terminal> var openProperty:String = "openProperty"
    <bin>1</bin>    fun testMethod():Unit{ println( "testMethod" ) }
    <bin>1</bin>    <terminal>open</terminal> fun openMethod():Unit{ println( "openMethod" ) }
    <bin>0</bin>}
    <bin>0</bin>
    <bin>0</bin>// class Derived : Base(){ //error , need <terminal>open</terminal> prefix for AgainDerived declaration
    <bin>0</bin><terminal>open</terminal> class Derived : Base(){
    <bin>1</bin>    // <eterminal>override</eterminal> var testProperty = 10 //error , because <terminal>final</terminal> default
    <bin>1</bin>    <terminal>override</terminal> var openProperty = "openProperty overriden"
    <bin>1</bin>    <terminal>final override</terminal> fun openMethod():Unit{ println("openMethod overriden") }
    <bin>0</bin>}
    <bin>0</bin>
    <bin>0</bin>class AgainDerived( <terminal>override var openProperty:String = "openProperty overriden again"</terminal> ) : Derived(){
    <bin>1</bin>    // <eterminal>override</eterminal> fun openMethod():Unit{ println( "openMethod overriden again" ) } //error , because <terminal>final</terminal> manually
    <bin>1</bin>    // <eterminal>override</eterminal> var openProperty:Int = 123 //error , <terminal>String</terminal> vs <terminal>Int</terminal>
    <bin>0</bin>}
    <bin>0</bin>
    <bin>0</bin>var test = Derived()
    <bin>0</bin>test.testMethod() //testMethod
    <bin>0</bin>test.openMethod() //openMethod overriden
    <bin>0</bin>println( test.openProperty ) //openProperty overriden
    <bin>0</bin>
    <bin>0</bin>var testAgain = AgainDerived()
    <bin>0</bin>println( testAgain.openProperty ) //openProperty overriden again
</codebox>
When designing a base class, you <marker>should therefore avoid</marker> using <terminal>open</terminal> members in the <terminal>constructors</terminal>, property initializers, and <terminal>init</terminal> blocks.
<a href="https://kotlinlang.org/docs/reference/classes.html#derived-class-initialization-order" target="_blank">weblink</a>