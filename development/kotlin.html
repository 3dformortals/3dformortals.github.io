<!DOCTYPE>
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>kotlin syntax</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="css/style.css" rel="stylesheet">
        
        <link rel="stylesheet" href="css/highlight/styles/zenburn.css">
        <script src="css/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        
    </head>
    <body>
    <script src="css/switchfont/switchfont.js"></script><br>
    <a class="up" id="c0" href="index.html">development &lt;&lt;&lt; kotlin syntax</a>
    
    <ol>
        <li><a class="up" href="#c1" >Bound callable references</a></li>
        <li><a class="up" href="#c2" >Underscores for unused parameters</a></li>
        <li><a class="up" href="#c3" >empty</a></li>
        <li><a class="up" href="#c4" >Shorter syntax for properties</a></li>
        
        <li><a class="up" href="#c5" >empty</a></li>
        
        <li><a class="up" href="#c6" ><terminal>onEach()</terminal> ... extension function for collections and sequences</a></li>
        <li><a class="up" href="#c7" ><terminal>apply()</terminal> ... extension function</a></li>
        <li><a class="up" href="#c8" ><terminal>also()</terminal> , <terminal>takeIf()</terminal> and <terminal>takeUnless()</terminal> ... extension functions</a></li>
        <li><a class="up" href="#c9" >Destructuring in lambdas</a></li>
        <li><a class="up" href="#c10" ><terminal>minOf()</terminal> and <terminal>maxOf()</terminal></a></li>
        <li><a class="up" href="#c11" ><terminal>Array()</terminal> like <terminal>List()</terminal> and <terminal>MutableList()</terminal></a></li>
        <li><a class="up" href="#c12" ><terminal>Arrays</terminal></a></li>
        <li><a class="up" href="#c13" ><terminal>List()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c14" ><terminal>Map()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c15" ><terminal>Set()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c16" ><terminal>Itarable()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c17" ><terminal>Collection()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c18" >Strings</a></li>
        <li><a class="up" href="#c19" >String Literals</a></li>
        <li><a class="up" href="#c20" >String Templates</a></li>
        <li><a class="up" href="#c21" >String to number conversions</a></li>
        <li><a class="up" href="#c22" >Char</a></li>
        <li><a class="up" href="#c23" >Bool</a></li>
        
        <li><a class="up" href="#c24" >Numbers</a></li>
        <li><a class="up" href="#c25" >Literal Constants</a></li>
        <li><a class="up" href="#c26" >Underscores in numeric literals</a></li>
        <li><a class="up" href="#c27" >Numbers comparison</a></li>
        <li><a class="up" href="#c28" >Numbers operations</a></li>
        <!--<li><a class="up" href="#c" ></a></li>-->
    </ol>
    <ol class="cover">
    <hr><li id="c1"><a href="#c0">Bound callable references</a></li>
    <codebox>
        val numberRegex = "\\d+".toRegex()
        <br>val numbers = listOf("abc", "123", "456").filter(numberRegex::matches)
    </codebox>
    
    <hr><li id="c2"><a href="#c0">Underscores for unused parameters</a></li>
    For a lambda with multiple parameters, you can use the <treminal>_</treminal> character to replace the names of the parameters you don't use:
    <codebox>
        map.forEach { _, value -> println("$value!") }
    </codebox>
    <br>This also works in destructuring declarations:
    <codebox>
        val (_, status) = function( ... )
        <br>for ((a, _) in collection) { ... }
    </codebox>
    
    <hr><li id="c3"><a href="#c0">empty</a></li>
    
    <hr><li id="c4"><a href="#c0">Shorter syntax for properties</a></li>
    <codebox>
        data class Person(val name: String, val age: Int) { val isAdult get() = age >= 20 // Property type inferred to be 'Boolean' }
    </codebox>
    
    <hr><li id="c5"><a href="#c0">empty</a></li>
    
    <hr><li id="c6"><a href="#c0">onEach() ... extension function for collections and sequences</a></li>
    <codebox>
        inputDir.walk()
        <br> .filter { it.isFile && it.name.endsWith(".txt") }
        <br> .onEach { println("Moving $it to $outputDir") }
        <br> .forEach { moveFile(it, File(outputDir, it.toRelativeString(inputDir))) }
    </codebox>
    
    <hr><li id="c7"><a href="#c0">apply() ... extension function</a></li>
    Normal syntax:
    <codebox>
        fun createInstance(args: Bundle) : MyFragment {
            <bin>1</bin>val fragment = MyFragment()
            <bin>1</bin>fragment.arguments = args
            <bin>1</bin>return fragment
        <br>}
    </codebox>
    <br>Improved syntax:
    <codebox>
        fun createInstance(args: Bundle) = MyFragment().apply { arguments = args }
    </codebox>
    <hr>
    Unchained object creation chain-able.
    <br>Normal syntax:
    <codebox>
        fun createIntent(intentData: String, intentAction: String): Intent {
            <bin>1</bin>val intent = Intent()
            <bin>1</bin>intent.action = intentAction
            <bin>1</bin>intent.data=Uri.parse(intentData)
            <bin>1</bin>return intent
        <br>}
    </codebox>
    <br>Improved syntax:
    <codebox>
        fun createIntent(intentData: String, intentAction: String) =
        <bin>1</bin>Intent().apply { action = intentAction }
        <bin>2</bin>.apply { data = Uri.parse(intentData) }
    </codebox>
    
    <hr><li id="c8"><a href="#c0">also(), takeIf() and takeUnless() ... extension functions</a></li>
    <terminal>also()</terminal> is like <terminal>apply()</terminal> , but reciever inside is available as <terminal>it</terminal> (inside <terminal>apply()</terminal> is available as <terminal>this</terminal>) .
    <codebox>
        fun Block.copy() = Block().also { it.content = this.content }
    </codebox>
    <hr>
    <terminal>takeIf()</terminal> is like filter for a single value, which returns the reciever or <terminal>null</terminal> .
    <codebox>
        val outDirFile = File(outputDir.path).takeIf { it.exists() } ?: return false
        <br>val index = input.indexOf(keyword).takeIf { it >= 0 } ?: error("keyword not found")
    </codebox>
    <hr>
    <terminal>takeUnless()</terminal> is inverted <terminal>takeIf()</terminal> .
    <codebox>
        val index = input.indexOf(keyword).takeUnless { it < 0 } ?: error("keyword not found")
        <br>val result = string.takeUnless(String::isEmpty)
    </codebox>
    
    <hr><li id="c9"><a href="#c0">Destructuring in lambdas</a></li>
    <codebox>
        val map = mapOf(2 to "one", 3 to "two")
        <br>println(map.mapValues { (key, value) -> "$key -> $value!" })
    </codebox>
    
    <hr><li id="c10"><a href="#c0">minOf() and maxOf()</a></li>
    <codebox>
        val list1 = listOf("a", "b")
        <br>val list2 = listOf("x", "y", "z")
        <br>val minSize = minOf(list1.size, list2.size)
        <br>val longestList = maxOf(list1, list2, compareBy { it.size })
    </codebox>
    
    <hr><li id="c11"><a href="#c0">Array() like List() and MutableList()</a></li>
    <codebox>
        val squares = List(4) { index -> index * index } //[0, 1, 4, 9]
        <br>val mutable = MutableList(4) { 0 } //[0, 0, 0, 0]
    </codebox>
    
    <hr><li id="c12"><a href="#c0">Arrays</a></li>
    
    
    <hr><li id="c13"><a href="#c0">List() kotlin.collections</a></li>
    <hr><li id="c14"><a href="#c0">Map() kotlin.collections</a></li>
    <hr><li id="c15"><a href="#c0">Set() kotlin.collections</a></li>
    <hr><li id="c16"><a href="#c0">Itarable() kotlin.collections</a></li>
    <hr><li id="c17"><a href="#c0">Collection() kotlin.collections</a></li>
    
    <hr><li id="c18"><a href="#c0">Strings</a></li>
    <hr><li id="c19"><a href="#c0">String Literals</a></li>
    <hr><li id="c20"><a href="#c0">String Templates</a></li>
    <hr><li id="c21"><a href="#c0">String to number conversions</a></li>
    Without throwing exception: <terminal>String.toIntOrNull(): Int?</terminal> <terminal>String.toDoubleOrNull(): Double?</terminal>
    <codebox>
        println(1_0.0) //10.0
        <br> println("10".toDouble()) //10.0
        <br> println("010".toDouble()) //10.0
        <br> //println("1_0".toDouble()) //NumberFormatException
        <br> println("10".toDoubleOrNull()) //10.0
        <br> println("1_0".toDoubleOrNull()) //null
    </codebox>
    <br>Overloadable integer conversion with <terminal>radix</terminal> parameter, which allows to specify the base of conversion (2 to 36):
    <br><terminal>Int.toString()</terminal> :
    <codebox>
        3.toString() //3
        <br> 3.toString(2)//11
        <br> 3.toString(radix=2)//11
        <br> //3.toString(huyadix=2)//Cannot find a parameter with this name: huyadix
        <br> //3.toString("2")//Type mismatch: inferred type is String but Int was expected
    </codebox>
    <br><terminal>String.toInt()</terminal> :
    <codebox>
        println(1_0) //10
        <br> //println("1_0".toInt()) //NumberFormatException
        <br> println("10".toInt()) //10
        <br> println("10".toInt(10).toInt()) //10
        <br> println("0010".toInt()) //10
        <br> //println("001_0".toInt()) //NumberFormatException
        <br> //println("00_10".toInt()) //NumberFormatException
        <br> //println("1.0".toInt()) //NumberFormatException
        <br> //println("001.0".toInt()) //NumberFormatException
        <br> //println(".10".toInt()) //NumberFormatException
        <br> //println("0.010".toInt()) //NumberFormatException
        <br> //println("10".toInt(10).toInt(10)) //Too many arguments for public open fun toInt()
        <br> println("10".toInt(2)) //2 radix=2 determine "10" as binary
        <br> println("0010".toInt(2)) //2
        <br> println("10".toInt(2).toInt()) //2
        <br> //println("0010".toInt(2).toInt(3)) //Too many arguments for public open fun toInt()
        <br> //println("String".toInt(2)) //NumberFormatException
    </codebox>
    <br><terminal>String.toIntOrNull()</terminal>
    <codebox>
        println(1_0) //10
        <br> println("1_0".toIntOrNull()) //null
        <br> println("10".toIntOrNull()) //10
        <br> //println("10".toIntOrNull(10).toIntOrNull()) //Unresolved reference
        <br> println("0010".toIntOrNull()) //10
        <br> println("001_0".toIntOrNull()) //null
        <br> println("00_10".toIntOrNull()) //null
        <br> println("1.0".toIntOrNull()) //null
        <br> println("001.0".toIntOrNull()) //null
        <br> println(".10".toIntOrNull()) //null
        <br> println("0.010".toIntOrNull()) //null
        <br> //println("10".toIntOrNull(10).toIntOrNull(10)) //Unresolved reference
        <br> println("10".toIntOrNull(2)) //2 radix=2 determine "10" as binary
        <br> println("0010".toIntOrNull(2)) //2
        <br> //println("10".toIntOrNull(2).toIntOrNull()) //Unresolved reference
        <br> //println("0010".toIntOrNull(2).toIntOrNull(3)) //Unresolved reference
        <br> println("String".toIntOrNull(2)) //null
    </codebox>
    
    <hr><li id="c22"><a href="#c0">Char</a></li>
    <hr><li id="c23"><a href="#c0">Bool</a></li>
    <hr><li id="c24"><a href="#c0">Numbers</a></li>
    <hr><li id="c25"><a href="#c0">Literal Constants</a></li>
    
    <hr><li id="c26"><a href="#c0">Underscores in numeric literals</a></li>
    <codebox>
            val oneMillion = 1_000_000
            <br>val hexBytes = 0xFF_EC_DE_5E
            <br>val bytes = 0b11010010_01101001_10010100_10010010
    </codebox>
    
    <hr><li id="c27"><a href="#c0">Numbers comparison</a></li>
    representation, explicit conversions, Floating Point Numbers Comparison
    
    <hr><li id="c28"><a href="#c0">Numbers operations</a></li>
    
    <!--<hr><li id="c"><a href="#c0">covertext</a></li><pre><code class="haxe"></code></pre>-->
    </ol>
    
    
    </body>
    <script src="css/indentation/indentation.js"></script><br>
</html>