<!DOCTYPE>
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>kotlin syntax</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="css/style.css" rel="stylesheet">
        
        <link rel="stylesheet" href="css/highlight/styles/zenburn.css">
        <script src="css/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        
    </head>
    <body>
    <script src="css/switchfont/switchfont.js"></script><br>
    <a class="up" id="c0" href="index.html">development &lt;&lt;&lt; kotlin syntax</a>
    
    <ol>
        <li><a class="up" href="#c1" >Bound callable references</a></li>
        <li><a class="up" href="#c2" >Underscores for unused parameters</a></li>
        <li><a class="up" href="#c3" >empty</a></li>
        <li><a class="up" href="#c4" >Shorter syntax for properties</a></li>
        
        <li><a class="up" href="#c5" >empty</a></li>
        
        <li><a class="up" href="#c6" ><terminal>onEach()</terminal> ... extension function for collections and sequences</a></li>
        <li><a class="up" href="#c7" ><terminal>apply()</terminal> ... extension function</a></li>
        <li><a class="up" href="#c8" ><terminal>also()</terminal> , <terminal>takeIf()</terminal> and <terminal>takeUnless()</terminal> ... extension functions</a></li>
        <li><a class="up" href="#c9" >Destructuring in lambdas</a></li>
        <li><a class="up" href="#c10" ><terminal>minOf()</terminal> and <terminal>maxOf()</terminal></a></li>
        <li><a class="up" href="#c11" ><terminal>Array()</terminal> like <terminal>List()</terminal> and <terminal>MutableList()</terminal></a></li>
        <li><a class="up" href="#c12" ><terminal>Arrays</terminal></a></li>
        <li><a class="up" href="#c13" ><terminal>List()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c14" ><terminal>Map()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c15" ><terminal>Set()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c16" ><terminal>Itarable()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c17" ><terminal>Collection()</terminal> kotlin.collections</a></li>
        <li><a class="up" href="#c18" >Strings</a></li>
        <li><a class="up" href="#c19" >String Literals</a></li>
        <li><a class="up" href="#c20" >String Templates</a></li>
        <li><a class="up" href="#c21" >String to number conversions</a></li>
        <li><a class="up" href="#c22" >Char</a></li>
        <li><a class="up" href="#c23" >Bool</a></li>
        
        <li><a class="up" href="#c24" >Numbers</a></li>
        <li><a class="up" href="#c25" >Literal Constants</a></li>
        <li><a class="up" href="#c26" >Underscores in numeric literals</a></li>
        <li><a class="up" href="#c27" >Numbers comparison</a></li>
        <li><a class="up" href="#c28" >Numbers operations</a></li>
        <li><a class="up" href="#c29" >Variables: <terminal>val</terminal> vs <terminal>var</terminal></a></li>
        <li><a class="up" href="#c30" >Control Flow: <terminal>if</terminal> , <terminal>when</terminal> , <terminal>for</terminal> , <terminal>while</terminal></a></li>
        <!--<li><a class="up" href="#c" ></a></li>-->
    </ol>
    <ol class="cover">
    <hr><li id="c1"><a href="#c0">Bound callable references</a></li>
    <codebox>
        val numberRegex = "\\d+".toRegex()
        <br>val numbers = listOf( "abc", "123", "456" ).filter( numberRegex::matches )
    </codebox>
    
    <hr><li id="c2"><a href="#c0">Underscores for unused parameters</a></li>
    For a lambda with multiple parameters, you can use the <treminal>_</treminal> character to replace the names of the parameters you don't use:
    <codebox>
        map.forEach { _, value -> println( "$value!" ) }
    </codebox>
    <br>This also works in destructuring declarations:
    <codebox>
        val ( _, status ) = function( ...  )
        <br>for ( ( a, _ ) in collection ) { ... }
    </codebox>
    
    <hr><li id="c3"><a href="#c0">empty</a></li>
    
    <hr><li id="c4"><a href="#c0">Shorter syntax for properties</a></li>
    <codebox>
        data class Person( val name: String, val age: Int ) { val isAdult get() = age >= 20 // Property type inferred to be 'Boolean' }
    </codebox>
    
    <hr><li id="c5"><a href="#c0">empty</a></li>
    
    <hr><li id="c6"><a href="#c0">onEach() ... extension function for collections and sequences</a></li>
    <codebox>
        inputDir.walk()
        <br> .filter { it.isFile && it.name.endsWith( ".txt" ) }
        <br> .onEach { println( "Moving $it to $outputDir" ) }
        <br> .forEach { moveFile( it, File( outputDir, it.toRelativeString( inputDir ) ) ) }
    </codebox>
    
    <hr><li id="c7"><a href="#c0">apply() ... extension function</a></li>
    Normal syntax:
    <codebox>
        fun createInstance( args: Bundle ) : MyFragment {
            <bin>1</bin>val fragment = MyFragment()
            <bin>1</bin>fragment.arguments = args
            <bin>1</bin>return fragment
        <br>}
    </codebox>
    <br>Improved syntax:
    <codebox>
        fun createInstance( args: Bundle ) = MyFragment().apply { arguments = args }
    </codebox>
    <hr>
    Unchained object creation chain-able.
    <br>Normal syntax:
    <codebox>
        fun createIntent( intentData: String, intentAction: String ): Intent {
            <bin>1</bin>val intent = Intent()
            <bin>1</bin>intent.action = intentAction
            <bin>1</bin>intent.data=Uri.parse( intentData )
            <bin>1</bin>return intent
        <br>}
    </codebox>
    <br>Improved syntax:
    <codebox>
        fun createIntent( intentData: String, intentAction: String ) =
        <bin>1</bin>Intent().apply { action = intentAction }
        <bin>2</bin>.apply { data = Uri.parse( intentData ) }
    </codebox>
    
    <hr><li id="c8"><a href="#c0">also(), takeIf() and takeUnless() ... extension functions</a></li>
    <terminal>also()</terminal> is like <terminal>apply()</terminal> , but reciever inside is available as <terminal>it</terminal> ( inside <terminal>apply()</terminal> is available as <terminal>this</terminal> ) .
    <codebox>
        fun Block.copy() = Block().also { it.content = this.content }
    </codebox>
    <hr>
    <terminal>takeIf()</terminal> is like filter for a single value, which returns the reciever or <terminal>null</terminal> .
    <codebox>
        val outDirFile = File( outputDir.path ).takeIf { it.exists() } ?: return false
        <br>val index = input.indexOf( keyword ).takeIf { it >= 0 } ?: error( "keyword not found" )
    </codebox>
    <hr>
    <terminal>takeUnless()</terminal> is inverted <terminal>takeIf()</terminal> .
    <codebox>
        val index = input.indexOf( keyword ).takeUnless { it < 0 } ?: error( "keyword not found" )
        <br>val result = string.takeUnless( String::isEmpty )
    </codebox>
    
    <hr><li id="c9"><a href="#c0">Destructuring in lambdas</a></li>
    <codebox>
        val map = mapOf( 2 to "one", 3 to "two" )
        <br>println( map.mapValues { ( key, value ) -> "$key -> $value!" } )
    </codebox>
    
    <hr><li id="c10"><a href="#c0">minOf() and maxOf()</a></li>
    <codebox>
        val list1 = listOf( "a", "b" )
        <br>val list2 = listOf( "x", "y", "z" )
        <br>val minSize = minOf( list1.size, list2.size )
        <br>val longestList = maxOf( list1, list2, compareBy { it.size } )
    </codebox>
    
    <hr><li id="c11"><a href="#c0">Array() like List() and MutableList()</a></li>
    <codebox>
        val squares = List( 4 ) { index -> index * index } //[0, 1, 4, 9]
        <br>val mutable = MutableList( 4 ) { 0 } //[0, 0, 0, 0]
    </codebox>
    
    <hr><li id="c12"><a href="#c0">Arrays</a></li>
    
    
    <hr><li id="c13"><a href="#c0">List() kotlin.collections</a></li>
    <hr><li id="c14"><a href="#c0">Map() kotlin.collections</a></li>
    <hr><li id="c15"><a href="#c0">Set() kotlin.collections</a></li>
    <hr><li id="c16"><a href="#c0">Itarable() kotlin.collections</a></li>
    <hr><li id="c17"><a href="#c0">Collection() kotlin.collections</a></li>
    
    <hr><li id="c18"><a href="#c0">Strings</a></li>
    <codebox>
        val s0 = "efgh" + 8 // efgh8
        <br> var s1 = "abcd"
        <br> for (c in s1){ print(c+" ") } // a b c d
        <br> println( s0 + s1 ) // efgh8abcd
        <br> s1 += s1; println(s1) //abcdabcd
        <br> //s1[0]= "e" //error
        <br> //s1 *= 2 //error
        <br> //s1 -= s1 //error
        <br> //println(s1 - s1) //error
    </codebox>
    
    <hr><li id="c19"><a href="#c0">String Literals</a></li>
    One quoted <terminal>"splitted\nstring"</terminal> , escaped strings may have characters <terminal>\t</terminal> , <terminal>\b</terminal> , <terminal>\n</terminal> , <terminal>\r</terminal> , <terminal>\'</terminal> , <terminal>\"</terminal> , <terminal>\\</terminal> , <terminal>\$</terminal> .
    <br> Triple quoted <terminal>"""multiline string"""</terminal> , raw strings, no escaped characters and may have new lines.
    <br> By default <terminal>|</terminal> is used as margin prefix. That change it to another character <terminal>&gt;</terminal> use <terminal>.trimMargin("&gt;")</terminal> or <terminal>.trinMargin("""\""")</terminal> in backslash case.
    
    <codebox>
        val eString = "splitted\nstring"
        <br> val etString = "tabulated\tstring"
        <br> println(etString) //tabulated<in>1</in>string
        <br> val mString = """multiline
        <br> string"""
        <br> val mtString = """multiline
        <br> string
        <bin>1</bin>with tabs"""
        <br> val msString = """multiline string with spaces<in>1</in>!<in>1</in>"""
        <br> println(msString) // multiline string with spaces<in>1</in>!<in>1</in>
        <br> val text = """
        <bin>1</bin>|Tell me and I forget. 
        <bin>1</bin>|Teach me and I remember.
        <bin>1</bin>""".trimMargin()
    </codebox>
    
    <hr><li id="c20"><a href="#c0">String Templates</a></li>
    <codebox>
        val i = 10
        <br> println("i = $i") // i = 10
        <br> val s = "abc"
        <br> println("$s.length is ${s.length}") // abc.length is 3
    </codebox>
    
    <hr><li id="c21"><a href="#c0">String to number conversions</a></li>
    Without throwing exception: <terminal>String.toIntOrNull(): Int?</terminal> , <terminal>String.toDoubleOrNull(): Double?</terminal>
    <codebox>
        println( 1_0.0 ) //10.0
        <br> println( "10".toDouble() ) //10.0
        <br> println( "010".toDouble() ) //10.0
        <br> //println( "1_0".toDouble() ) //NumberFormatException
        <br> println( "10".toDoubleOrNull() ) //10.0
        <br> println( "1_0".toDoubleOrNull() ) //null
    </codebox>
    <br>Overloadable integer conversion with <terminal>radix</terminal> parameter, which allows to specify the base of conversion ( 2 to 36 ):
    <br><terminal>Int.toString()</terminal> :
    <codebox>
        3.toString() //3
        <br> 3.toString( 2 )//11
        <br> 3.toString( radix=2 )//11
        <br> //3.toString( huyadix=2 )//Cannot find a parameter with this name: huyadix
        <br> //3.toString( "2" )//Type mismatch: inferred type is String but Int was expected
    </codebox>
    <br><terminal>String.toInt()</terminal> :
    <codebox>
        println( 1_0 ) //10
        <br> //println( "1_0".toInt() ) //NumberFormatException
        <br> println( "10".toInt() ) //10
        <br> println( "10".toInt( 10 ).toInt() ) //10
        <br> println( "0010".toInt() ) //10
        <br> //println( "001_0".toInt() ) //NumberFormatException
        <br> //println( "00_10".toInt() ) //NumberFormatException
        <br> //println( "1.0".toInt() ) //NumberFormatException
        <br> //println( "001.0".toInt() ) //NumberFormatException
        <br> //println( ".10".toInt() ) //NumberFormatException
        <br> //println( "0.010".toInt() ) //NumberFormatException
        <br> //println( "10".toInt( 10 ).toInt( 10 ) ) //Too many arguments for public open fun toInt()
        <br> println( "10".toInt( 2 ) ) //2 radix=2 determine "10" as binary
        <br> println( "0010".toInt( 2 ) ) //2
        <br> println( "10".toInt( 2 ).toInt() ) //2
        <br> //println( "0010".toInt( 2 ).toInt( 3 ) ) //Too many arguments for public open fun toInt()
        <br> //println( "String".toInt( 2 ) ) //NumberFormatException
    </codebox>
    <br><terminal>String.toIntOrNull()</terminal>
    <codebox>
        println( 1_0 ) //10
        <br> println( "1_0".toIntOrNull() ) //null
        <br> println( "10".toIntOrNull() ) //10
        <br> //println( "10".toIntOrNull( 10 ).toIntOrNull() ) //Unresolved reference
        <br> println( "0010".toIntOrNull() ) //10
        <br> println( "001_0".toIntOrNull() ) //null
        <br> println( "00_10".toIntOrNull() ) //null
        <br> println( "1.0".toIntOrNull() ) //null
        <br> println( "001.0".toIntOrNull() ) //null
        <br> println( ".10".toIntOrNull() ) //null
        <br> println( "0.010".toIntOrNull() ) //null
        <br> //println( "10".toIntOrNull( 10 ).toIntOrNull( 10 ) ) //Unresolved reference
        <br> println( "10".toIntOrNull( 2 ) ) //2 radix=2 determine "10" as binary
        <br> println( "0010".toIntOrNull( 2 ) ) //2
        <br> //println( "10".toIntOrNull( 2 ).toIntOrNull() ) //Unresolved reference
        <br> //println( "0010".toIntOrNull( 2 ).toIntOrNull( 3 ) ) //Unresolved reference
        <br> println( "String".toIntOrNull( 2 ) ) //null
    </codebox>
    
    <hr><li id="c22"><a href="#c0">Char</a></li>
    <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-char/index.html" target="_blank" >API weblink</a>.
    Represents a 16-bit Unicode character. On the JVM, non-nullable values of this type are represented as values of the primitive type <terminal>Char</terminal> . Can not be treated directly as numbers. Boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.
    <br>Character literals go in single quotes: <terminal>'1'</terminal> .
    <br>Special characters <terminal>\t</terminal> <terminal>\b</terminal> <terminal>\n</terminal> <terminal>\r</terminal> <terminal>\'</terminal> <terminal>\"</terminal> <terminal>\\</terminal> <terminal>\$</terminal> can be escaped using a backslash.
    <br>Any other characters can be encoded uses the Unicode escape sequence syntax: <terminal>'\uFF00'</terminal> .
    <br><br>Can be explicitly converted to an <terminal>Int</terminal> number:
    <codebox>
        val c: Char = '1'
        <br> println( c.toInt() - '2'.toInt() ) // -1
        <br> println( c - 'a' ) //-48
        <br> println( c - 'a'.toInt() ) //￐
        <br> println( c.toInt() - 'a'.toInt() ) //-48
        <br> //println( c.toInt() - 'a' ) //error
    </codebox>
    <br> Methods:
    <codebox>
        println( 'a'.toInt() ) //97
        <br> println( 'd'.toInt() ) //100
        <br> println( 'd'.toDouble() ) //100.0
        <br> println( 'd'.toFloat() ) //100.0
        <br> println( 'd'.toLong() ) //100
        <br> println( 'd'.toShort() ) //100
        <br> println( 'a'.compareTo( 'd' ) ) //-1
        <br> println( 'd'.compareTo( 'a' ) ) //1
        <br> println( 'a'.compareTo( 'a' ) ) //0
        <br> println( 'a'.inc() ) //b
        <br> println( 'd'.dec() ) //c
        <br> println( 'a'.minus( 'd' ) ) //-3
        <br> //println( 'a'.plus( 'd' ) ) //error
        <br> println( 'a'.plus( 'd'.toInt() ) ) //Å
        <br> println( 'd'.minus( 3 ) ) //a
        <br> println( 'a'.plus( 3 ) ) //d
        <br> 
        <br> println( 'a'.rangeTo( 'd' ).toString() ) //a..d
        <br> println( 'a'.rangeTo( 'd' ).toList() ) //[a, b, c, d]
        <br> println( 'a'.rangeTo( 'd' ).drop(0) ) //[a, b, c, d]
        <br> 
        <br> println( 'd'.rangeTo( 'a' ).toString() ) //d..a
        <br> println( 'd'.rangeTo( 'a' ).toList() ) //[ ]
        <br> println( 'd'.rangeTo( 'a' ).drop(0) ) //[ ]
        <br> 
        <br> println( 'a'.toByte() ) //97
        <br> println( 'd'.toChar() ) //d
    </codebox>
    <br>Extension functions:
    <br><terminal>downTo()</terminal> :
    <codebox>
        val da = 'd'.downTo( 'a' ) //d downTo a step 1
        <br> println( da ) //d downTo a step 1
        <br> println( da.drop( 0 ) ) //[d, c, b, a]
        <br> 
        <br> val ad = 'a'.downTo( 'd' ) //a downTo d step 1
        <br> println( ad ) //a downTo d step 1
        <br> println( ad.drop( 0 ) ) //[ ]
        <br> 
        <br> val cda = CharRange( 'd','a' ) //d..a
        <br> println( cda ) //d..a
        <br> println( cda.drop( 0 ) ) //[ ]
        <br> 
        <br> val cad = CharRange( 'a','d' ) //a..d
        <br> println( cad ) //a..d
        <br> println( cad.drop( 0 ) ) //[a, b, c, d]
    </codebox>
    
    <br><terminal>equals()</terminal> :
    <codebox>
        println( 'a'.equals( 'A' ) ) //false
        <br> println( 'a'.equals( 'A', true ) ) //true
        <br> 
        <br> println( 'a'.equals( 'B' ) ) //false
        <br> println( 'a'.equals( 'B', true ) ) //false
    </codebox>
    
    <br><terminal>isLowerCase()</terminal> , <terminal>isUpperCase()</terminal> , <terminal>isWhitespace()</terminal> , <terminal>toLowerCase()</terminal> , <terminal>toUpperCase()</terminal> :
    <codebox>
        println( 'a'.isLowerCase() ) //true
        <br> println( 'a'.isUpperCase() ) //false
        <br> println( 'A'.isLowerCase() ) //false
        <br> println( 'A'.isUpperCase() ) //true
        <br> 
        <br> //println( ''.isWhitespace() ) //error
        <br> println( 'a'.isWhitespace() ) //false
        <br> println( '\b'.isWhitespace() ) //false
        <br> println( '\$'.isWhitespace() ) //false
        <br> println( ' '.isWhitespace() ) //true
        <br> println( '\n'.isWhitespace() ) //true
        <br> println( '\t'.isWhitespace() ) //true
        <br> println( '\r'.isWhitespace() ) //true
        <br>
        <br> println( 'A'.toLowerCase() ) //a
        <br> println( 'a'.toUpperCase() ) //A
        <br> //println( ''.toUpperCase() ) //error
        <br> println( ' '.toUpperCase() ) // 
        <br> println( '\n'.toUpperCase() ) //
    </codebox>
    
    <hr><li id="c23"><a href="#c0">Bool</a></li>
    
    
    <hr><li id="c24"><a href="#c0">Numbers</a></li>
    <terminal>Type</terminal> Bit width 
    <terminal>Double</terminal> 64
    <terminal>Float</terminal> 32
    <terminal>Long</terminal> 64
    <terminal>Int</terminal> 32
    <terminal>Short</terminal> 16
    <terminal>Byte</terminal> 8
    
    <hr><li id="c25"><a href="#c0">Literal Constants</a></li>
    Decimals: <terminal>123</terminal>
    <br>Longs: <terminal>123L</terminal>
    <br>Hexadecimals: <terminal>0x0F</terminal>
    <br>Binaries: <terminal>0b00001011</terminal>
    <br>Doubles: <terminal>123.5</terminal> , <terminal>123.5e10</terminal>
    <br>Floats: <terminal>123.5f</terminal> , <terminal>123.5F</terminal>
    
    <hr><li id="c26"><a href="#c0">Underscores in numeric literals</a></li>
    <codebox>
        val oneMillion = 1_000_000
        <br> val creditCardNumber = 1234_5678_9012_3456L
        <br> val socialSecurityNumber = 999_99_9999L
        <br> val hexBytes = 0xFF_EC_DE_5E
        <br> val bytes = 0b11010010_01101001_10010100_10010010
    </codebox>
    
    <hr><li id="c27"><a href="#c0">Numbers comparison</a></li>
    Boxed store, when need nullable number reference ( e.g. <terminal>Int?</terminal> ) or generics are involved:
    <codebox>
        val a: Int = 10000
        <br> val boxedA: Int? = a
        <br> val anotherBoxedA: Int? = a
        <br> println( a === a ) // true . Deprecated
        <br> println( boxedA === anotherBoxedA ) // false
        <br> println( a == a ) // true
        <br> println( boxedA == anotherBoxedA ) // true
    </codebox>
    
    <br>Primitive types store ( e.g. <terminal>Int</terminal> ):
    <codebox>
        val b: Int = 10000
        <br> val primitiveB: Int = b
        <br> val anotherPrimitiveB: Int = b
        <br> println( b === b ) // true . Deprecated
        <br> println( primitiveB === anotherPrimitiveB ) // true . Deprecated
        <br> println( b == b ) // true
        <br> println( primitiveB == anotherPrimitiveB ) // true
    </codebox>
    
    <br>Different boxed types comparison:
    <codebox>
        val a: Int? = 1 // A boxed Int ( java.lang.Integer )
        <br> //val b: Long? = a // Type mismatch: inferred type is Int? but Long? was expected
        <br> val b: Long? = 2
        <br> //print( b == a ) // Operator '==' cannot be applied to 'Long?' and 'Int?'
    </codebox>
    
    <br>Different types comparison:
    <codebox>
        val b: Byte = 1
        <br> //val i: Int = b // Type mismatch: inferred type is Byte but Int was expected
        <br> val i: Int = 2
        <br> //println( b == i ) // Operator '==' cannot be applied to 'Byte' and 'Int'
    </codebox>
    
    <br>Every number type supports conversions:
    <br> <terminal>toByte(): Byte</terminal>
    <br> <terminal>toShort(): Short</terminal>
    <br> <terminal>toInt(): Int</terminal>
    <br> <terminal>toLong(): Long</terminal>
    <br> <terminal>toFloat(): Float</terminal>
    <br> <terminal>toDouble(): Double</terminal>
    <br> <terminal>toChar(): Char</terminal> .
    Kotlin <terminal>Char</terminal> is not a number type.
    <codebox>
        val l = 1L + 3 // Long + Int => Long
        <br> val b: Byte = 1
        <br> val i: Int = b.toInt()
        <br> println( b.toInt() === i ) //true . Deprecated
        <br> println( b.toInt() == i ) //true
        <br> //println( b === i ) // Operator '===' cannot be applied to 'Byte' and 'Int'
        <br> //println( b == i ) // Operator '===' cannot be applied to 'Byte' and 'Int'
        <br> //val c:Byte = b + 3 // Type mismatch: inferred type is Int but Byte was expected
        <br> //val c:Byte = b + i // Type mismatch: inferred type is Int but Byte was expected
        <br> //val c:Byte = 3 + b // Type mismatch: inferred type is Int but Byte was expected
        <br> //val c:Byte = i + b // Type mismatch: inferred type is Int but Byte was expected
        <br> val c:Int = i + b
        <br> val d:Int = b + i
        <br> println( c ) //2
        <br> println( d ) //2
        <br> println( i+b ) //2
        <br> println( b+i ) //2
        <br> val e:Int = i + 0b11010010
        <br> val f:Int = 0b11010010 + i
        <br> println( e ) //211
        <br> println( f ) //211
        <br> println( 2.5 + 0b11010010 ) //212.5
    </codebox>
    
    <br>Floating Point Numbers Comparison.
    <br> Equality checks: <terminal>a == b</terminal> and <terminal>a != b</terminal>
    <br> Comparison operators: <terminal>a &lt; b</terminal> , <terminal>a &gt; b</terminal> , <terminal>a &lt;= b</terminal> , <terminal>a &gt;= b</terminal>
    <br> Range instantiation and range checks: <terminal>a..b</terminal> , <terminal>x in a..b</terminal> , <terminal>x !in a..b</terminal>
    
    <br><br>When operands are not statically typed as floating point numbers ( e.g. Any, Comparable<...>, a type parameter ), the operations use the <terminal>equals</terminal> and <terminal>compareTo</terminal> implementations for <terminal>Float</terminal> and <terminal>Double</terminal> , so that:
    <br> <terminal>NaN</terminal> is considered equal to itself
    <br> <terminal>NaN</terminal> is considered greater than any other element including <terminal>POSITIVE_INFINITY</terminal>
    <br> <terminal>-0.0</terminal> is considered less than <terminal>0.0</terminal>
    
    <hr><li id="c28"><a href="#c0">Numbers operations</a></li>
    Bitwise operations ( available for <terminal>Int</terminal> and <terminal>Long</terminal> only ):
    <br> <terminal>shl( bits )</terminal> - signed shift left ( Java's &lt;&lt; )
    <br> <terminal>shr( bits )</terminal> - signed shift right ( Java's &gt;&gt; )
    <br> <terminal>ushr( bits )</terminal> - unsigned shift right ( Java's &gt;&gt;&gt; )
    <br> <terminal>and( bits )</terminal> - bitwise and
    <br> <terminal>or( bits )</terminal> - bitwise or
    <br> <terminal>xor( bits )</terminal> - bitwise xor
    <br> <terminal>inv()</terminal> - bitwise inversion
    <hr>
    Increment , decrement:
    <br>Single syntax <terminal>x++</terminal> and <terminal>++x</terminal> is close to <terminal>x = x + 1</terminal> .
    <br>Single syntax <terminal>x--</terminal> and <terminal>--x</terminal> is close to <terminal>x = x - 1</terminal> .
    <br>But have difference when these syntaxes is part of big syntax:
    <codebox>
        var x = 11
        <br> x++; println( x ) // 12
        <br> ++x; println( x ) // 13
        <br> x--; println( x ) // 12
        <br> --x; println( x ) // 11
        <br> //but
        <br> println( x++ ) // 11 ,because first was <terminal>println( x )</terminal> , second was <terminal>x = x + 1</terminal>
        <br> println( x ) // 12
        <br> 
        <br> println( ++x ) // 13 ,because first was <terminal>x = x + 1</terminal> , second was <terminal>println( x )</terminal>
        <br> println( x ) // 13
        <br> 
        <br> println( x-- ) // 13 ,because first was <terminal>println( x )</terminal> , second was <terminal>x = x - 1</terminal>
        <br> println( x ) // 12
        <br> 
        <br> println( --x ) // 11 ,because first was <terminal>x = x - 1</terminal> , second was <terminal>println( x )</terminal>
        <br> println( x ) // 11
    </codebox>
    <br> <terminal>x += y</terminal> is equal <terminal>x = x + y</terminal> .
    <br> <terminal>x -= y</terminal> is equal <terminal>x = x - y</terminal> .
    <br> <terminal>x /= y</terminal> is equal <terminal>x = x / y</terminal> .
    <br> <terminal>x *= y</terminal> is equal <terminal>x = x * y</terminal> .
    <br> <terminal>x %= y</terminal> is equal <terminal>x = x % y</terminal> .
    <codebox>
        var x = 11.5
        <br> //x = 11 // error
        <br> x = 11.0
        <br> var y = 2
        <br> 
        <br> x += y ; println( x ) //13.0
        <br> x -= y ; println( x ) //11.0
        <br> x *= y ; println( x ) //22.0
        <br> x /= y ; println( x ) //11.0
        <br> x %= y ; println( x ) //1.0 ... 11 / 2 = [5](integer) -> 11 - ( 2 * [5] ) = 1
        <br> x = 11.0
        <br> x %= 3 ; println( x ) //2.0 ... 11 / 3 = [3](integer) -> 11 - ( 3 * [3] ) = 2
    </codebox>
    
    <hr><li id="c29"><a href="#c0">Variables: <terminal>val</terminal> vs <terminal>var</terminal></a></li>
    <codebox>
        val vaLx = 0 //something like constant
        <br> //for(i in 1..5){ vaLx ++ } // Val cannot be reassigned
        <br> var vaRx = 0 //something like standard variable
        <br> for(i in 1..5){ vaRx ++ }
        <br> println(vaRx) // 5
    </codebox>
    
    <hr><li id="c30"><a href="#c0">Control Flow: <terminal>if</terminal> , <terminal>when</terminal> , <terminal>for</terminal> , <terminal>while</terminal></a></li>
    <terminal>if</terminal> :
    <codebox>
        <br> if ( a > b ) big = a
        <br> if ( a > b ) {
            <bin>1</bin>big = a }
        <br> if ( a > b ) big = a else big = b
        <br> if ( a > b ) { big = a } else { if ( b > a ) big = b }
        <br> if ( a > b ) { big = a } else if ( b > a ) { big = b }
        <br> if ( a > b ) big = a else if ( b > a ) big = b
        <br> big = if ( a > b ) a else b // this form always need <terminal>else</terminal>
        <br> big = if (a > b) {
                <bin>1</bin>print("case a ")
                <bin>1</bin>a //this is block value
            <br> } else if ( b > a ){
                <bin>1</bin>print("case b ")
                <bin>1</bin>b //this is block value
            <br> } else {
                <bin>1</bin>print("other case ")
                <bin>1</bin>b*a //this is block value
            <br> } //this form always need <terminal>else</terminal>
    </codebox>
    
    <br><terminal>when</terminal> is similar to switch operator in other languages:
    <codebox>
        when(x){
            <bin>1</bin>1 -> print("x == 1")
            <bin>1</bin>2 -> { print("x == 2") }
            <bin>1</bin>else -> {
                <bin>2</bin>print("not 1")
                <bin>2</bin>print(" not 2")
            }
        }
        <br><br>when(x){ 1 -> { print("x == 1") } 2 -> { print("x == 2") } else -> { print("not 1"); print(" not 2") }}
        
        <br><br>when (x){
            <bin>1</bin>0, 1 -> print("x == 0 or x == 1")
            <bin>1</bin>s.toInt() -> print("x==$s")
            <bin>1</bin>else -> print("otherwise")
        }
        <br>
        <br>val x = 22; val s = "2"
        <br>when(x){ ( s + "2" ).toInt() -> print( "x==( \""+s+"2"+"\" ).toInt()" ) /* x==( "22" ).toInt()*/ }
        <br>
        <br>val validNumbers = arrayOf(22,33)
        <br>when (x) {
            <bin>1</bin>in 1..10 -> print("x is in the range")
            <bin>1</bin>in validNumbers -> print("x is valid")
            <bin>1</bin>!in 10..20 -> print("x is outside the range")
            <bin>1</bin>else -> print("none of the above")
        <br>}
    </codebox>
    Another possibility is to check that a value is or !is of a particular type.
    <codebox>
        fun hasPrefix(x: Any) = when(x) {
            <bin>1</bin>is String -> x.startsWith("prefix")
            <bin>1</bin>else -> false
        }
    </codebox>
    Replacement for an <terminal>if-else if</terminal> chain.
    <codebox>
        when {
            <bin>1</bin>x.isOdd() -> print("x is odd")
            <bin>1</bin>x.isEven() -> print("x is even")
            <bin>1</bin>else -> print("x is funny")
        <br>}
    </codebox>
    
    <br><terminal>for</terminal> loop:
    <codebox>
        for (item in collection) print(item)
        <br> for (item in collection) { print(item) }
        <br> for (item in collection) {
            <bin>1</bin>print(item) }
        <br> for (ind in collection.indices) {
            <bin>1</bin>print(collection[ind]) }
        <br> for ((index, value) in array.withIndex()) println("the element at $index is $value")
        <br> for (i in 1..3) println(i)
        <br> for (i in 1..3 step 2) println(i)
        <br> //for (i in 1..3 step -2) println(i) //error
        <br> //for (i in 3..1 step -2) println(i) //error
        <br> for (i in 6 downTo 0 step 2) println(i)
        <br> for (i:Int in 6 downTo 0 step 2) println(i)
        <br> //for (i:Long in 6 downTo 0 step 2) println(i) //error
        <br> //for (i:Byte in 6 downTo 0 step 2) println(i) //error
    </codebox>
    
    <br><terminal>while</terminal> and <terminal>do..while</terminal> loops:
    <codebox>
        var x = 2; while (x>0) { print(x--); } //21
        <br> x = 2; while (x>0) { print(--x); } //10
        <br> x = 2; do { print(x); print(x--) } while (x > 0) //2211
        <br> //do (print(x); print(x--)) while (x > 0) //error
        <br> //do print(x); print(x--) while (x > 0) //error
        <br> x = 2; do print(x--) while (x > 0) //21
    </codebox>
    <br>Returns and jumps <a href="http://kotlinlang.org/docs/reference/returns.html#returns-and-jumps" target="_blank">weblink</a> .
    <br> <terminal>return</terminal> result from function. Return can be named.
    
    <br> <terminal>break</terminal> terminates the nearest enclosing loop.
    Or terminates named loop:
    <codebox>
        loop1@ for (i in 1..3){
            <bin>1</bin>loop2@ for (ii in 1..5){
                <bin>2</bin>if (ii==2){ print("ii="+ii+" i="+i); break@loop1 } //ii=2 i=1
            <bin>1</bin>}
        }
        <br> loop1@ for (i in 1..3) loop2@ for (ii in 1..5) if (ii==2){ print("ii="+ii+" i="+i); break@loop1 } //ii=2 i=1
    </codebox>
    
    <br> <terminal>continue</terminal> proceeds to the next step of the nearest enclosing loop. Can be named similar as <terminal>break</terminal> .
    
    <br>Precedence <a href="http://kotlinlang.org/docs/reference/grammar.html#precedence" target="_blank">weblink</a>
    
    <!--<hr><li id="c"><a href="#c0">covertext</a></li><pre><code class="haxe"></code></pre>-->
    </ol>
    
    
    </body>
    <script src="css/indentation/indentation.js"></script><br>
</html>